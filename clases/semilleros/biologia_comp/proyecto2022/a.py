#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Script that extract the primers from raw sequencing reads and evaluates the
frequency of each primer pair. If desired, it can also extract the paired
reads generated by each primer pair into separate files.
Nicolás Pinel
npinelp@eafit.edu.co
Universidad EAFIT
Medellín, Colombia
March 31, 2021
"""

import argparse
import re
import itertools
from collections import defaultdict
from Bio import SeqIO
from fuzzywuzzy import process

# For a brief tutorial on how to use the package FuzzyWuzzy, see:
# https://www.datacamp.com/community/tutorials/fuzzy-string-python.

####################
# Global variables #
####################

# Dictionary for expanding primer sequences into all of their possible
# combinations.
IUPAC_degeneracies = {
    "W": ["A", "T"],  # Weak
    "S": ["C", "G"],  # Strong
    "M": ["A", "C"],  # Amino
    "K": ["G", "T"],  # Keto
    "R": ["A", "G"],  # Purine
    "Y": ["C", "T"],  # Pyrimidine
    "B": ["C", "G", "T"],  # Not A
    "D": ["A", "G", "T"],  # Not C
    "H": ["A", "C", "T"],  # Not G
    "V": ["A", "C", "G"],  # Not T
    "N": ["A", "C", "G", "T"],  # Any base
}

# Dictionary that will house the primer sequences and their names.
primers = {}
# Dictionary that will hold all the primer pairs detected. It is defined
# as a "defaultdict" class, as it can become a multidimensional dictionary
# when option "--separate" is used.
primer_pairs = defaultdict(dict)


#############
# Functions #
#############


def expand_degeneracies(degenerate_sequence):
    """
    A function to generate all possible permutations of a DNA sequence (e.g., a
    primer) when degeneracies are specified in it. Returns the list of all
    possible sequences.
    The function uses itertools.product to generate the cartesian products (all
    possible combinations). It expands each element in the sequence as a
    (unitary) list, which it then replaces for a multi-member list if the letter
    is codified in the IUPAC code dictionary (defined externally). It then
    performs the unpack operation with the '*' operator for executing
    'itertools.product'.
    """

    # Convert the degenerate sequence into a list of characters.
    degen_seq = list(degenerate_sequence)

    # Replace degenerate characters for a string of all possible options; these
    # will be expanded by 'itertools.product'.

    for i in range(0, len(degen_seq)):
        if degen_seq[i] in IUPAC_degeneracies:
            degen_seq[i] = "".join(IUPAC_degeneracies[degen_seq[i]])

    # Return all possible combinations as strings.
    return ["".join(x) for x in itertools.product(*degen_seq)]


def find_primer(query_seq):
    """
    A function for identifying the primer in a sequenced read. It depends on a
    previously created primer dictionary (which it receives as an argument).
    The flow is as follows:
    1) Iterate over all primers in the dictionary performing exact matches. If
       found, breaks.
    2) If an exact match is not found, it performs fuzzy matching (using the
       FuzzyWuzzy Python library) and assigns the primer with the highest match
       score IF above the threshold (80%).
    3) Primers with match scores below the threshold are marked as unknown;
       sequences beginning with poly-N's are given primers "NNN".
    The function returns a tuple that includes the primer name, and the match
    score (100 if exact, 0 if N, or the Fuzzy Score otherwise). In the current
    version, the score is not being used, but in future versions it will be used
    to analyze possible variants not reported in the primer list.
    """

    primer_in_seq = ""  # Variable to be returned.
    primer_match_score = 0  # Match score defaults to 0.
    missing = True  # Logical for forking to fuzzy.

    # Perform exact matches.
    for primer in primers.keys():
        if query_seq.startswith(primer):
            primer_in_seq = primers[primer]
            primer_match_score = 100
            missing = False
            break

    # If an exact match is not found, check for N's, or perform fuzzy.
    if missing:
        if re.search(r"N{3,}", query_seq):
            primer_in_seq = "NNN"
        else:
            highest_match = process.extractOne(query_seq, list(primers.keys()))

            if len(highest_match[0]) != len(query_seq):
                # The query sequence is passed with the length of the longest
                # primer, which can mismatch past the true primer length.
                query_seq = query_seq[: len(highest_match[0])]
                highest_match = process.extractOne(
                    query_seq, list(primers.keys()))

            primer_match_score = highest_match[1]

            if highest_match[1] < 80:
                primer_in_seq = "UNK"
            else:
                primer_in_seq = primers[highest_match[0]]

    return [primer_in_seq, primer_match_score]


def construct_primer_dictionary(primers_file):
    """A function to populate the dictionary of primer sequences."""

    with open(primers_file, "r") as ihandle:

        for record in SeqIO.parse(ihandle, "fasta"):
            sequence = str(record.seq)

            if re.search(r"\D?[WSMKRYBDHVN]\D?", sequence):
                primer_variants = expand_degeneracies(sequence)

                for primer_var in primer_variants:
                    primers[primer_var] = record.id

            else:
                primers[sequence] = record.id


def construct_argparser():
    """Create an argparse object to collect command line arguments."""

    parser = argparse.ArgumentParser(prog="primer_pair_profiling.py")

    parser.add_argument(
        "-p",
        "--primers",
        help="fasta-formated file with primer sequences to be searched",
        required=True,
    )
    parser.add_argument(
        "-f",
        "--forward",
        help="forward read sequences file in format fast[a|q]",
        required=True,
    )
    parser.add_argument(
        "-r",
        "--reverse",
        help="reverse read sequences file; optional if forward reads file \
              carries '_R1' in the file name, otherwise it must be specified",
    )
    parser.add_argument(
        "-s",
        "--separate",
        action="store_true",
        help="output the primer pair reads into separate sequence files",
    )
    parser.add_argument(
        "-m",
        "--minreads",
        type=int,
        default=1000,
        help="minimum number of reads for the primer pair in orther to \
              separate them into files",
    )

    command_line_arguments = parser.parse_args()
    return command_line_arguments


def write_seqs(ppair, sfile, fformat, srecords):
    """Creates separate sequence files for each primer pair."""

    p_pair = ppair.replace("/", "_x_")
    f_ext = re.search(r"\.\D+$", sfile).group()
    o_file = sfile.replace(f_ext, "__" + p_pair + f_ext)

    SeqIO.write(srecords, o_file, fformat)


def print_outputs(sep, mseqs, ffor, frev, ffmt):
    """Print the tallies, and if appropriate, write sequences."""

    if sep:
        for items in sorted(
            primer_pairs.items(),
            reverse=True,
            key=lambda x: len(primer_pairs[x[0]]["R1"]),
        ):

            num_seqs = len(primer_pairs[items[0]]["R1"])
            print(items[0], "\t", num_seqs)

            if num_seqs >= mseqs:
                write_seqs(items[0], ffor, ffmt, primer_pairs[items[0]]["R1"])
                write_seqs(items[0], frev, ffmt, primer_pairs[items[0]]["R2"])

    else:
        for items in sorted(primer_pairs.items(), reverse=True, key=lambda x: x[1]):
            print(items[0], "\t", items[1])


def populate_primer_pairs(file_fwd, file_rev, file_fmt, primer_lng, separate):
    """Creates the dictionary to keep the tally of all primer pairs."""

    with open(file_fwd, "r") as handle_forward, open(file_rev, "r") as handle_reverse:

        # Iterate simulatenously over the forward and reverse sequence records
        for rec_forward, rec_reverse in zip(
            SeqIO.parse(handle_forward, file_fmt), SeqIO.parse(
                handle_reverse, file_fmt)
        ):

            primer_forward = find_primer(str(rec_forward.seq[:primer_lng]))
            primer_reverse = find_primer(str(rec_reverse.seq[:primer_lng]))
            primer_pair = [primer_forward[0], primer_reverse[0]]

            # Sort the list based on the last character of each primer name
            primer_pair.sort(key=lambda x: str.lower(list(x)[-1]))
            primer_pair_str = "/".join(primer_pair)

            if separate:
                if primer_pair_str in primer_pairs:
                    primer_pairs[primer_pair_str]["R1"].append(rec_forward)
                    primer_pairs[primer_pair_str]["R2"].append(rec_reverse)
                else:
                    primer_pairs[primer_pair_str]["R1"] = [rec_forward]
                    primer_pairs[primer_pair_str]["R2"] = [rec_reverse]
            else:
                if primer_pair_str in primer_pairs:
                    primer_pairs[primer_pair_str] += 1
                else:
                    primer_pairs[primer_pair_str] = 1


def main():
    """Driving code."""

    args = construct_argparser()

    construct_primer_dictionary(args.primers)
    primer_lng_max = max(map(len, primers.keys()))

    file_forward = args.forward
    file_reverse = (
        args.reverse if args.reverse else file_forward.replace("_R1", "_R2")
    )
    file_format = "fastq" if re.search(r"\D+q$", file_forward) else "fasta"

    populate_primer_pairs(
        file_forward, file_reverse, file_format, primer_lng_max, args.separate
    )

    print_outputs(args.separate, args.minreads,
                  file_forward, file_reverse, file_format)


if __name__ == "__main__":
    main()
